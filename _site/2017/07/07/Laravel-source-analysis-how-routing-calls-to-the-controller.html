<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="/stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/print.css" media="print" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title> laravel 源码分析-路由是如何调用到控制器 </title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1> 麦索的麦田 </h1>
        <h2>Nothing is impossible</h2>
        <a href="/" class="button"><small>go back</small>Index</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          
          <h2>laravel 源码分析-路由是如何调用到控制器</h2>
<p class="meta">2017-07-07</p>

<h3 id="概述">概述</h3>

<p>laravel 的路由相比其他PHP框架非常灵活和优雅，它也能做的在url不变的情况下改变调用的控制器和方法。</p>

<p>那么这到底在 laravel 里是怎么完成的呢</p>

<h3 id="路由到底是如何获取的">路由到底是如何获取的？</h3>

<p>这没什么神秘的，回忆一下我们写一个单页过程化 PHP 脚本时我们是如何接收 HTML 页面传输的参数的？</p>

<p>是的，也许你想起来了我们会使用 PHP 的超全局变量 <code class="highlighter-rouge">$_SERVER</code>、<code class="highlighter-rouge">$_GET</code>、<code class="highlighter-rouge">$_POST</code> 等等，是的框架的底层同样是使用它们的，只是框架进行了更详尽的封装。</p>

<p>laravel 对 Symfony 框架提供的 HttpFoundation 组件，这个组件对 HTTP 进行了面向对象封装，laravel在其基础上又进行了封装，以适合 laravel 框架自身的需求。</p>

<p>HttpFoundation 组件将 <code class="highlighter-rouge">$_GET</code>、<code class="highlighter-rouge">$_POST</code>、<code class="highlighter-rouge">$_FILES</code>、<code class="highlighter-rouge">$_COOKIE</code> 等一些超全局变量进行封装，不仅将超全局变量调用转变为面向对象的方式，而且也简化了操作。比如 <code class="highlighter-rouge">Symfony\Component\HttpFoundation\Request::createFromGlobals() </code> 的返回值就是所有超全局组成的一个集合。</p>

<p>如果你对这个组件感兴趣可以查看其文档 <a href="https://symfony.com/doc/current/components/http_foundation.html">HttpFoundation</a></p>

<h3 id="路由是如何启动的">路由是如何启动的？</h3>

<p>路由启动我们要从原点找起，那么原点就是 laravel 框架的入口文件 <code class="highlighter-rouge">public/index.php</code>。</p>

<p>index.php 里首先把 bootstrap/autoload.php 引入，这个文件引入的是 composer 的 autoload 文件，将所有的包加载到脚本里，这个脚本文件还定义了一个常量 LARAVEL_START 记录了框架启动的微秒时间戳。</p>

<p>然后引入了 bootstrap/app.php 脚本，这个脚本加载了 laravl 框架的核心文件，返回了一个应用实例。</p>

<p>随后就是后续步骤</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 得到应用核心实例
$kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class);

// 对请求处理后获得响应
$response = $kernel-&gt;handle(
    $request = Illuminate\Http\Request::capture() // 获得请求参数
);

// 发送响应
$response-&gt;send();

// 终止
$kernel-&gt;terminate($request, $response);
</code></pre></div></div>

<p>我们想知道路由在哪分配调用就在 <code class="highlighter-rouge">$kernel-&gt;handle()</code> 这里，其中调用了 <code class="highlighter-rouge">$this-sendRequestThroughRouter()</code>，这里就将请求发送给了中间件和路由。</p>

<p><code class="highlighter-rouge">$this-&gt;dispatchToRouter()</code>  中 <code class="highlighter-rouge">$this-&gt;router-&gt;dispatch($request)</code> 就将请求传入到 Router 类中了。</p>

<p>然后再 Router 类的 <code class="highlighter-rouge">dispatch()</code> 的方法中调用了 Router 类的 <code class="highlighter-rouge">dispatchToRoute()</code> 方法将请求向下传递。</p>

<p>在<code class="highlighter-rouge">dispatchToRoute()</code>中你会发现 <code class="highlighter-rouge">$route = $this-&gt;findRoute($request);</code>的调用。
<code class="highlighter-rouge">findRoute()</code> 中调用 RouteCollection 类中的 <code class="highlighter-rouge">match()</code> 方法去匹配在初始化框架时读取到内存中的开发者在路由定义文件里定义的路由，如果未匹配到就抛出 <code class="highlighter-rouge">NotFoundHttpException</code> 异常。如匹配到就返回了 Route 类的实例。</p>

<p>然后这个实例在 Router 类的 <code class="highlighter-rouge">dispatchToRoute()</code> 方法中实例有被传入到 <code class="highlighter-rouge">runRouteWithinStack()</code> 方法。这个方法中又调用多个方法将匹配到的开发者定义的 URL 的映射的控制器实例化，去调用控制器的 <code class="highlighter-rouge">callAction()</code> 方法，<code class="highlighter-rouge">callAction()</code> 写在控制器的基类中，就是我们写一个控制器都要继承的那个 <code class="highlighter-rouge">Conreoller</code> 类中。</p>

<p>方法很简单，就是讲传入的方法名和参数用 PHP 函数 <code class="highlighter-rouge">call_user_func_array()</code> 进行调用。</p>

<p>以上是我们的最佳实践。但是在你初始化 laravel 框架的时候他的首页是以下这样调用的。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Route::get('/', function () {
    return view('welcome');
});
</code></pre></div></div>

<p>路由中使用匿名函数，在调用控制器的实例前框架先会判断是否是一个控制器动作，如何不是就获取路由中的匿名函数进行调用。判断的依据就是开发者定义的路由的第二个参数是否是一个字符串。</p>

<p>这是 laravel 路由的主流程，其他中间件调用，Request 验证等等都在主流程的各个步骤中附加分发调用了。</p>



<!--PC和WAP自适应版-->
<div id="SOHUCS" sid="laravel 源码分析-路由是如何调用到控制器" ></div>
<script type="text/javascript">
(function(){
var appid = 'cyt8K3bay';
var conf = 'prod_4cce8456a31ddba41cd9cd6ae71a8ee7';
var width = window.innerWidth || document.documentElement.clientWidth;
if (width < 960) {
window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="http://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("http://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>


        </section>

        <aside id="sidebar">
          <!--<a href="https://github.com/pietromenna/jekyll-architect-theme/archive/master.zip" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/pietromenna/jekyll-architect-theme/archive/master.tar.gz" class="button">
            <small>Download</small>
            .tar.gz file
          </a>-->

          <p class="repo-owner"><a href="https://github.com/jasonlong/architect-theme">architect-theme</a> is maintained by <a href="https://github.com/jasonlong">jasonlong</a>.</p>

          <p class="repo-owner"><a href="https://github.com/pietromenna/jekyll-architect-theme">jekyll-architect-theme</a> is maintained by <a href="https://github.com/pietromenna">pietromenna</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</p>
        </aside>
      </div>
    </div>

  </body>
</html>
